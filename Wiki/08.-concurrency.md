---
id: 8
title: 8. Concurrency & Timing in Verse
tags: [verse, concurrency, timing, sleep, loops, cooldown]
summary: Practical patterns for timing, repetition, and background-like tasks using simple, readable Verse constructs.
---

# Concurrency & Timing

Game logic often needs **delays**, **repetition**, and **cooldowns**. Keep concurrency patterns simple and observable for reliability and training.

---

## 1) Delays with Sleep

```verse
DoHealAfterDelay(Seconds : float, Amount : float) : void =
    Sleep(Seconds)
    HealFirstPlayer(Amount)
```

- Use `Sleep` to stage actions over time (e.g., intro sequences).

---

## 2) Periodic Loops (Pollers)

```verse
RunPeriodicDamage(IntervalSeconds : float, Amount : float, Ticks : int) : void =
    i : int = 0
    loop:
        if (i >= Ticks):
            return
        HurtFirstPlayer(Amount)
        Sleep(IntervalSeconds)
        set i = i + 1
```

- A bounded loop with `Sleep` avoids tight spin loops.

---

## 3) Cooldowns & Debounce

```verse
CanUseAbility? : logic = true

UseAbility(Amount : float, Cooldown : float) : void =
    if (CanUseAbility?):
        set CanUseAbility? = false
        HurtFirstPlayer(Amount)
        Sleep(Cooldown)
        set CanUseAbility? = true
```

- Simple shared state controls usage rate.

---

## 4) Chaining with Failure Contexts

Guard checks inside loops for safe access:

```verse
PingPlayerHealth(Interval : float, Ticks : int) : void =
    if (Char : fort_character = TryGetFirstCharacter[]):
        i : int = 0
        loop:
            if (i >= Ticks):
                return
            Print("HP: {Char.GetHealth()}")
            Sleep(Interval)
            set i = i + 1
```

- If the character lookup fails, nothing runs.

---

## 5) Design Tips

- Prefer **bounded** loops or explicit exit conditions.
- Keep shared mutable state minimal and well-named.
- Isolate long-running sequences into dedicated helpers.

---

## 6) Finetuning Notes (LLM)

- Favor small, orthogonal examples (delay, loop, cooldown).
- Include prints to make time-based behavior observable.
