---
id: 24
title: 24. Distances & Movement Utilities in Verse — Vector Helpers and Chase Patterns
tags: [verse, vectors, distance, movement, transforms]
summary: Reusable helpers for measuring distances, checking ranges, and writing simple chase/approach patterns with readable logs.
---

# Distances & Movement Utilities

This page collects small, **self-contained** utilities for vectors and movement logic. Do calculations **first**, then apply effects at the **bottom** of a guarded block.

> Use **XY distance** for planar checks and **3D distance** when verticality matters. Keep **units** consistent across your map (e.g., Unreal units).

---

## 1) Getting Positions

```verse
GetCharLocation(Char : fort_character) : vector3 =
    return Char.GetTransform().Translation
```

- Retrieve positional data via transforms; bind to locals to avoid redundant calls.

---

## 2) Vector Helpers

```verse
Delta(A : vector3, B : vector3) : vector3 =
    return vector3{X := B.X - A.X, Y := B.Y - A.Y, Z := B.Z - A.Z}

Length2D(V : vector3) : float =
    return Sqrt(V.X * V.X + V.Y * V.Y)

Length3D(V : vector3) : float =
    return Sqrt(V.X * V.X + V.Y * V.Y + V.Z * V.Z)

DistanceXY(A : vector3, B : vector3) : float =
    return Length2D(Delta(A, B))

Distance3D(A : vector3, B : vector3) : float =
    return Length3D(Delta(A, B))
```

- Keep math helpers **pure** (no effects) for reuse and testability.

---

## 3) Range Checks & Radii

```verse
WithinRadiusXY(Center : vector3, Target : vector3, Radius : float) : logic =
    return DistanceXY(Center, Target) <= Radius

WithinRadius3D(Center : vector3, Target : vector3, Radius : float) : logic =
    return Distance3D(Center, Target) <= Radius
```

- Boolean helpers communicate intent clearly and reduce repetition.

---

## 4) Approach / Chase (Kinematic Step)

```verse
MoveTowardsXY(Current : vector3, Target : vector3, Step : float) : vector3 =
    D := Delta(Current, Target)
    Dist := Length2D(D)
    if (Dist <= Step or Dist = 0.0):
        return vector3{X := Target.X, Y := Target.Y, Z := Current.Z}
    NX := D.X / Dist
    NY := D.Y / Dist
    return vector3{X := Current.X + NX * Step, Y := Current.Y + NY * Step, Z := Current.Z}
```

- Returns a **new** XY position one step closer; apply it with your movement/teleport API.

---

## 5) Worked Example — Chase First Player for N Steps

```verse
ChaseFirstPlayer(Step : float, Steps : int) : void =
    if (P : player = GetPlayspace().GetPlayers()[0]):
        if (Char : fort_character = P.GetFortCharacter[]):
            i : int = 0
            Pos := vector3{X:=0.0, Y:=0.0, Z:=300.0}   # demo origin
            loop:
                if (i >= Steps):
                    return
                Target := GetCharLocation(Char)
                Next   := MoveTowardsXY(Pos, Target, Step)
                Print("Chase step {i}: pos={Pos} -> {Next} (distXY={DistanceXY(Pos, Target)})")
                # Implementation note: call your movement API here
                set Pos = Next
                Sleep(0.2)
                set i = i + 1
```

- Separate **computation** from the final **effect** call for clarity.

---

## 6) Positive vs. Negative Examples

**Good**
```verse
if (WithinRadiusXY(A, B, 500.0)):
    Print("Reached the target radius")
```

**Poor**
```verse
if (DistanceXY(A, B) < 500.0) Print("Reached")  # compressed and inconsistent style
```

---

## 7) Finetuning Notes (LLM)

- Prefer pure helpers and short logs with stable keys.
- Show both **success** (within radius) and **progress** (chase steps).
- Place effects at the bottom of guarded blocks.
