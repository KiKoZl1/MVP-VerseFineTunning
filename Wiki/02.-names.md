---
id: 2
title: 2. Names & Identifiers in Verse — Rules, Collisions, and Best Practices
tags: [verse, identifiers, naming, scope, keywords]
summary: What identifiers can look like in Verse, how case-sensitivity and scope affect them, and how to avoid common collisions.
---

# Names & Identifiers in Verse

Identifiers are the **symbols** you create for variables, constants, functions, types, and more. Verse is **case-sensitive** and has **reserved keywords**.

---

## 1) Identifier Rules (At a Glance)

- Start with a **letter** or `_`, then letters, digits, or `_`.
- **No spaces** or punctuation inside identifiers.
- **Case-sensitive**: `PlayerHealth` and `playerhealth` are different.
- **Reserved keywords** cannot be used as identifiers (e.g., `if`, `else`, `return`, `var`).

> Use the project style guide for **which casing** to prefer. Epic-provided names (e.g., `fort_character`) keep their original casing.

---

## 2) Scope and Lifetime

- **Local scope:** names declared inside a function exist only within that function.
- **File/module scope:** names declared at file level are visible to functions defined in the same file.
- **Shadowing:** avoid reusing a name in an inner scope that hides an outer binding — it reduces clarity and causes subtle bugs.

**Example (avoid shadowing):**
```verse
Coins : int = 100

SpendCoins(Coins : int) : void =   # BAD: parameter shadows file-level Coins
    # ... logic ...
```

**Preferred:**
```verse
Coins : int = 100

SpendCoins(Amount : int) : void =
    # ... logic ...
```

---

## 3) Collisions & Namespaces

- Use `using { ... }` to import Verse/UEFN libraries. Keep imports at the top of the file.
- If two imported modules export the same identifier, use **qualified** names to disambiguate, or rename locally with an alias if available.
- Keep project-defined names **distinct from API names** to reduce confusion.

---

## 4) Readability Heuristics

- **Descriptive first**: prefer `MoveThreshold` over `MT`.
- **Include units** or domain hints: `SleepSeconds`, `CoinsPerMousetrap`.
- **Boolean semantics**: `IsAlive?`, `HasKey?`.
- **Pluralization** for collections: `Players` and `Player`.

---

## 5) Common Pitfalls

- **Case mismatches** (`OnBegin` vs. `onbegin`) lead to compile-time errors or logic that never executes.
- **Magic numbers** without meaning — extract to a constant (`CoinsPerMousetrap`).
- **Overloading abbreviations** (`hp`, `spd`, `cnt`) across contexts — makes examples ambiguous for both humans and models.

---

## 6) Examples

**Good**
```verse
OnBegin<override>() : void =
    Playspace := GetPlayspace()
    Players   := Playspace.GetPlayers()

    if (P : player = Players[0]):
        if (Char : fort_character = P.GetFortCharacter[]):
            IsLowHealth? : logic = Char.GetHealth() < 50.0
            if (IsLowHealth?):
                HealPlayer(HealAmount := 20.0)
```

**Poor**
```verse
onbegin() : void =      # wrong case for event
    pl := GetPlayspace().GetPlayers()
    if (x = pl[0]):
        c := x.GetFortCharacter[]
        if (c):
            HealPlayer(20)
```

---

## 7) Finetuning Notes (LLM)

- Prefer **full words** over terse abbreviations.
- Keep boolean naming consistent with `?` suffix.
- Mix engine-provided identifiers with project-defined ones to teach disambiguation.
