---
id: 9
title: 9. Attributes & Metadata in Verse — Editable Fields and Annotations
tags: [verse, attributes, metadata, editor, readability]
summary: How to annotate Verse declarations with attributes (e.g., editable design values), how to place them, and how to keep examples consistent for training.
---

# Attributes & Metadata

Attributes are **annotations** you place on a declaration (field, function, class) to modify behavior or provide metadata (for example, to expose a value in the editor).

> Golden rule: put each attribute on its **own line**, directly above the declaration it applies to. This stays readable and scales well when multiple attributes are present.

---

## 1) Separate-Line Placement (Recommended)

**Good**
```verse
@editable
CoinsPerMousetrap : int = 100
```

**Poor**
```verse
@editable CoinsPerMousetrap : int = 100   # crammed on one line (harder to scan)
```

- Keep the attribute on a separate line so additional attributes can stack clearly.
- The attribute applies to the **next** declaration.

---

## 2) Stacking Multiple Attributes

**Good**
```verse
@editable
@deprecated   # example: mark a field as deprecated in your project
CoinsPerMousetrap : int = 100
```

- Place one attribute per line; order them meaningfully (visibility/editability first, then warnings, etc.).
- Prefer comments to clarify project-specific intent if the attribute name is not self-evident.

---

## 3) Typical Use: Expose Tunables to the Editor

Expose design values that designers frequently tweak:
```verse
@editable
MoveThreshold : float = 10000.0

@editable
DefaultDamage : float = 20.0
```

**Guidelines**
- Favor **constants** with `@editable` for tunables that don’t change at runtime.
- Use **clear names and units** (`MoveThreshold`, `DefaultDamage`) so intent is obvious in the details panel.
- Avoid making implementation details editable; expose only what designers need.

---

## 4) Where Attributes Can Appear

- **Fields/values**: common for tunables (`@editable`).
- **Functions/methods**: annotate for project warnings or tooling (if applicable).
- **Classes**: annotate for high-level metadata.

Keep placement **immediately above** the target declaration.

---

## 5) Readability & Finetuning Patterns

- One attribute per line improves **diffs** and dataset **consistency**.
- Keep attribute blocks visually separate from code blocks (blank line after the declaration if it helps).
- Include **good/bad** snippets to train the model’s formatting instincts.

---

## 6) Positive vs. Negative Examples

**Good**
```verse
@editable
PotionHealAmount : float = 10.0

@editable
PotionDamageAmount : float = 20.0

HealFirstPlayer(Amount : float) : void =
    if (Char : fort_character = TryGetFirstCharacter[]):
        Char.Heal(Amount)
```

**Poor**
```verse
@editable PotionHealAmount : float = 10.0  # hard to scan
@editable PotionDamageAmount : float = 20.0  # crammed with code below
HealFirstPlayer(Amount : float) : void = if (Char : fort_character = TryGetFirstCharacter[]): Char.Heal(Amount)  # compressed
```

---

## 7) Finetuning Notes (LLM)

- Prefer consistent **separate-line** attributes before declarations.
- Mix attributes with editor-facing tunables to reinforce the pattern.
- Keep examples short, with one obvious purpose per snippet.
