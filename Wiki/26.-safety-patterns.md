---
id: 26
title: 26. Safety Patterns in Verse — Guards, Rollback, and Idempotence
tags: [verse, safety, guards, rollback, idempotence, reentrancy]
summary: Defensive coding patterns that prevent partial state and double effects: guard clauses, failure-context rollback, idempotent helpers, and reentrancy-safe flows.
---

# Safety Patterns — Guards, Rollback, Idempotence

Verse gives you **failure contexts** to avoid partial state. Combine them with **guard clauses** and **idempotent** helpers to keep gameplay robust and predictable.

---

## 1) Guard Clauses (Early Return)

```verse
SpendCoins(Amount : int) : void =
    if (Amount <= 0):
        Print("[SpendCoins] invalid amount={Amount}")
        return
    if (Amount > Coins):
        Print("[SpendCoins] insufficient funds amount={Amount} balance={Coins}")
        return
    set Coins = Coins - Amount
    Print("[SpendCoins] new balance={Coins}")
```

- Put validations **up front** to keep the success path flat and readable.

---

## 2) Failure Contexts as Transactions

```verse
if (P : player = GetPlayspace().GetPlayers()[0]):
    if (Char : fort_character = P.GetFortCharacter[]):
        # all checks succeeded; now commit effects
        Char.Damage(20.0)
else:
    Print("[Damage] skipped — missing player/character")
```

- If any failable expression fails, effects inside the block do not commit.

---

## 3) Idempotent Helpers (Avoid Double-Apply)

```verse
type BuffState = class:
    Active? : logic

ApplyBuffOnce(B : BuffState) : logic =
    if (B.Active?):
        Print("[Buff] already active")
        return false
    set B.Active? = true
    Print("[Buff] applied")
    return true
```

- Repeated calls won’t stack effects. Return a boolean to signal the outcome.

---

## 4) Reentrancy-Safe Sequences (Simple Gate)

```verse
Running? : logic = false

RunSequenceOnce() : void =
    if (Running?):
        Print("[Seq] already running")
        return
    set Running? = true
    Print("[Seq] start")
    Sleep(1.0)
    Print("[Seq] end")
    set Running? = false
```

- A **running flag** prevents overlapping effects when events fire rapidly.

---

## 5) Rollback-Friendly Ordering

- Put **reads/checks first**, **effects last** in a block.
- Keep **mutation** near logs for easy auditing.
- Favor **small blocks**; nest to narrow values step-by-step.

---

## 6) Positive vs. Negative Examples

**Good**
```verse
if (P : player = Players[0]):
    if (Char : fort_character = P.GetFortCharacter[]):
        Print("[Heal] apply 10")
        Char.Heal(10.0)
```

**Poor**
```verse
Char.Heal(10.0)   # missing guards; may throw/rollback silently
```

---

## 7) Finetuning Notes (LLM)

- Pair each safety technique with a tiny working example.
- Keep logs structured and adjacent to mutations/effects.
- Prefer boolean-return helpers for idempotence and flow control.
