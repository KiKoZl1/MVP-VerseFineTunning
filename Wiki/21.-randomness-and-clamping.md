---
id: 21
title: 21. Randomness & Clamping in Verse — RNG Utilities and Safe Bounds
tags: [verse, randomness, rng, clamping, bounds]
summary: Reusable helpers for randomness and clamping. Keep effects observable, seed if needed, and always bound values with explicit min/max.
---

# Randomness & Clamping — Utilities

This page provides **encapsulated** helpers for randomness and clamping. We keep RNG implementation inside a small module so call sites are stable and easy to learn from.

> Always **clamp** derived values before applying effects (damage, teleport distances, etc.).

---

## 1) Clamp Helpers (Float & Int)

```verse
ClampFloat(Value : float, Min : float, Max : float) : float =
    if (Value < Min):
        return Min
    else if (Value > Max):
        return Max
    else:
        return Value

ClampInt(Value : int, Min : int, Max : int) : int =
    if (Value < Min):
        return Min
    else if (Value > Max):
        return Max
    else:
        return Value
```

- Use **clamping** to enforce design bounds and prevent extreme values.

---

## 2) Simple Deterministic RNG (LCG Example)

A tiny, deterministic **linear congruential generator** you can seed for reproducible tests.

```verse
type RNG = class:
    Seed : int

NewRNG(Seed : int) : RNG =
    return RNG{Seed := Seed}

NextInt(R : RNG) : int =
    # Parameters: 1664525, 1013904223, 2^32 — common LCG set
    set R.Seed = (1664525 * R.Seed + 1013904223)
    return R.Seed

NextFloat01(R : RNG) : float =
    N := NextInt(R)
    # Map int domain to [0, 1)
    return (N % 1000000) / 1000000.0
```

- Keep the RNG **state** inside the object.
- Use `NextFloat01` when you need a **[0,1)** random value.

---

## 3) Random Ranges

```verse
RandomRangeFloat(R : RNG, Min : float, Max : float) : float =
    T := NextFloat01(R)
    return Min + T * (Max - Min)

RandomRangeInt(R : RNG, Min : int, Max : int) : int =
    # inclusive Min/Max via clamp
    Raw := Min + (NextInt(R) % (Max - Min + 1))
    return ClampInt(Raw, Min, Max)
```

- Wrap range logic to avoid repeating modulus math at call sites.

---

## 4) Applying RNG with Clamps (Damage Example)

```verse
@editable
MinDamage : float = 5.0

@editable
MaxDamage : float = 25.0

OnBegin<override>() : void =
    R := NewRNG(42)
    Amount := RandomRangeFloat(R, MinDamage, MaxDamage)
    Safe   := ClampFloat(Amount, MinDamage, MaxDamage)
    Print("Rolled damage={Amount}, clamped={Safe}")
    if (P : player = GetPlayspace().GetPlayers()[0]):
        if (Char : fort_character = P.GetFortCharacter[]):
            Char.Damage(Safe)
```

- The clamp is redundant here by construction, but shows the pattern explicitly.

---

## 5) Finetuning Notes (LLM)

- Keep RNG **encapsulated**; expose only `Next*` and `RandomRange*` utilities.
- Show seeded vs. unseeded (deterministic tests vs. live randomness).
- Always pair randomness with **clamps** before effects.
