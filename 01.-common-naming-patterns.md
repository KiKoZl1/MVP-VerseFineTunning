---
id: 1
title: 1. Common Naming Patterns for Verse (Project Style Guide)
tags: [verse, naming, identifiers, conventions, style]
summary: Unified naming conventions for this project to keep all Verse examples consistent and easy for a model to learn.
---

# Common Naming Patterns (Project-Wide)

This page standardizes how we **name things** across the entire dataset. Consistent naming improves readability, reduces bugs, and makes patterns easier for a model to learn during finetuning.

> **Note:** Verse is case-sensitive. Engine/built-in names keep their original casing (often `snake_case` for Fortnite API types like `fort_character`). Our **project-defined** names follow the conventions below.

---

## 1) Global Conventions

- **Types/Classes (project-defined):** `PascalCase` — e.g., `MouseTrapService`, `DamageCalculator`.
- **Functions & Methods (project-defined):** `PascalCase` with action verbs — e.g., `HurtPlayer`, `HealPlayer`, `CalculateDamage`.
- **Variables & Constants:** `PascalCase` — e.g., `MoveThreshold`, `DamageAmount`, `Players`. Keep names descriptive.
- **Booleans:** suffix with `?` when they represent a logical query — e.g., `Tired?`, `FriendsAvailable?`.
- **Collections:** plural for lists/arrays, singular for elements — e.g., `Players` and `Player`, `Mice` and `Mouse`.
- **Units in names:** make units explicit — e.g., `SleepSeconds`, `MoveThresholdMeters`, `DamageAmount` (if unitless by design, include a doc comment).

> We keep **PascalCase** for project-defined identifiers to align with examples used throughout these docs. Built-in Verse/UEFN types and methods retain their Epic-provided casing (e.g., `fort_character`, `GetPlayspace`).

---

## 2) Semantic Prefixes & Suffixes

Use consistent prefixes/suffixes to convey intent:

- **Get/Set:** data access or mutation, e.g., `GetPlayers`, `SetMaxHealth`.
- **Is/Has/Can:** boolean semantics, e.g., `IsAlive?`, `HasKey?`, `CanAfford?`.
- **Try/Find:** operations that might fail (pair well with failure contexts), e.g., `TryGetWeapon`, `FindSpawnPoint`.
- **Count/Total/Amount:** numeric aggregation, e.g., `MiceCount`, `CoinsTotal`, `DamageAmount`.
- **Min/Max/Limit/Threshold:** bounds and design constants, e.g., `MinHealth`, `MaxHealth`, `MoveThreshold`.

---

## 3) Scope & Lifetime Hints in Names

- **Locals**: short but meaningful (`P`, `Char`) are acceptable within tight scopes, especially inside failure contexts that narrow types.
- **File-level constants**: group near the top; include intent in the name (`MoveThreshold`, `CoinsPerMousetrap`).
- **Avoid shadowing**: don’t reuse names in nested scopes when the outer binding remains relevant.

---

## 4) Positive vs. Negative Examples

**Good**
```verse
MoveThreshold : float = 10000.0
Players       := GetPlayspace().GetPlayers()

if (P : player = Players[0]):
    if (Char : fort_character = P.GetFortCharacter[]):
        IsLowHealth? : logic = Char.GetHealth() < 30.0
        if (IsLowHealth?):
            HurtPlayer(DamageAmount := 10.0)
```

**Poor**
```verse
mt : float = 10000     # vague
p := GetPlayspace().GetPlayers()
if (pl = p[0]):        # ambiguous names, loses intent
    c := pl.GetFortCharacter[]
    if (c):            # unclear boolean; no ? suffix
        HP := 30       # magic number; unit unknown
```

---

## 5) Finetuning Notes (LLM)

- Keep names stable across examples to reinforce patterns.
- Favor **descriptive nouns/verbs** over abbreviations.
- Include paired good/bad snippets to sharpen the model’s distinctions.
