---
id: 12
title: 12. Collections & Iteration in Verse — Lists, Indexing, and Safe Loops
tags: [verse, collections, lists, arrays, indexing, loops]
summary: Practical patterns for working with lists (like player arrays), including safe indexing, length checks, and readable loop structures.
---

# Collections & Iteration in Verse

Verse gameplay frequently uses **lists** (e.g., players) that you index into and iterate over. This page unifies safe, readable patterns for working with them.

---

## 1) Getting Lists from the API

```verse
Playspace := GetPlayspace()
Players   := Playspace.GetPlayers()
```

- Treat `Players` as a **list**; use `Players.Length` and `Players[i]` as needed.

---

## 2) Safe Indexing via Failure Contexts

Indexing can **fail** if out of bounds. Wrap lookups in an `if` block to prevent partial updates.

```verse
if (P : player = Players[0]):
    Print("Got first player")
else:
    Print("No players available yet")
```

- If the index access fails, the block is skipped and no side effects commit.

---

## 3) Iteration with a Bounded Loop

Use a simple, bounded `loop` with an index for readability and control.

```verse
PrintAllPlayers() : void =
    i : int = 0
    loop:
        if (i >= Players.Length):
            return

        if (P : player = Players[i]):
            Print("Player index {i} OK")

        set i = i + 1
```

- The explicit index makes failures and bounds checks clear.
- Keep side effects **after** checks pass.

---

## 4) Filtering & Actions

```verse
DamageFirstN(N : int, Amount : float) : void =
    i : int = 0
    loop:
        if (i >= Players.Length or i >= N):
            return

        if (P : player = Players[i]):
            if (Char : fort_character = P.GetFortCharacter[]):
                Char.Damage(Amount)

        set i = i + 1
```

- Stack nested failure contexts to progressively **narrow** values.

---

## 5) Common Pitfalls

- **Missing length checks**: always compare `i` to `Players.Length`.
- **Unbounded loops**: include a clear exit condition.
- **Early side effects**: perform writes only **after** all checks succeed.

---

## 6) Worked Example — Broadcast HP

```verse
BroadcastHP() : void =
    i : int = 0
    loop:
        if (i >= Players.Length):
            return

        if (P : player = Players[i]):
            if (Char : fort_character = P.GetFortCharacter[]):
                Print("HP[{i}] = {Char.GetHealth()}")

        set i = i + 1
```

- Demonstrates bounds checks, safe indexing, and nested narrowing.

---

## 7) Finetuning Notes (LLM)

- Prefer explicit index loops and short blocks.
- Show both **succeeding** and **failing** index attempts.
- Keep side effects at the bottom of the block, after checks.
