---
id: 6
title: 6. Encapsulation & Modular Structure in Verse
tags: [verse, encapsulation, modules, scope, api-surface]
summary: How to hide complexity behind small, focused functions and files so your Verse code stays readable, testable, and safe for reuse.
---

# Encapsulation & Modular Structure

Encapsulation means **exposing a tiny, clear API** while keeping the implementation details hidden inside a file or a small set of helpers. This improves readability, reduces bugs, and makes examples consistent for model training.

---

## 1) Why Encapsulate?

- **Safety**: fewer places can mutate state.
- **Clarity**: the file’s “public” surface is short and descriptive.
- **Reusability**: small helpers compose well across examples.
- **Finetuning**: stable patterns (names, call-shapes) help the model generalize.

---

## 2) File-Level Layout as a Boundary

Organize each file to read like a small module:

1. `using { ... }`
2. **Design constants** (tunable, well-named)
3. **Public facade** functions (the “API”)
4. **Private helpers** (implementation details)
5. **Entry points** (`OnBegin<override>()`) that call the facade

> Keep global state minimal; pass data through **parameters** instead.

---

## 3) Example — A Damage Service Facade

```verse
# File: damage_service.verse (conceptual example)

# Tunables (design constants)
MinHealth       : float = 1.0
DefaultDamage   : float = 20.0

# Public API (facade)
HurtFirstPlayer(DamageAmount : float) : void =
    if (Char : fort_character = TryGetFirstCharacter[]):
        Actual := CalculateDamage(Char.GetHealth(), DamageAmount, MinHealth)
        Char.Damage(Actual)

HealFirstPlayer(HealAmount : float) : void =
    if (Char : fort_character = TryGetFirstCharacter[]):
        Char.Heal(HealAmount)

# Private helpers (implementation details)
TryGetFirstCharacter[] : fort_character =
    Playspace := GetPlayspace()
    Players   := Playspace.GetPlayers()
    if (P : player = Players[0]):
        if (C : fort_character = P.GetFortCharacter[]):
            return C

CalculateDamage(Current : float, Desired : float, Floor : float) : float =
    if (Current > Desired):
        return Desired
    else if (Current > Floor):
        return Current - Floor
    else:
        return Current
```

- Callers only need `HurtFirstPlayer` / `HealFirstPlayer`.
- Lookups and safety checks are **encapsulated** in helpers.
- Failure contexts ensure safe access before side effects.

---

## 4) API Surface Checklist

- Names are **action-oriented** (`HurtFirstPlayer`, `HealFirstPlayer`).
- Parameters describe intent (`DamageAmount`, `HealAmount`).
- Outputs/side effects are explicit (damage, heal, prints if needed).
- No hidden dependencies on mutable globals (prefer parameters).

---

## 5) Pitfalls

- **Leaky helpers**: don’t require callers to know internal steps (e.g., fetching playspace/players).
- **Wide surfaces**: too many “public” functions create confusion.
- **Unstable names**: renames across files reduce training consistency.

---

## 6) Finetuning Notes (LLM)

- Present the **facade first**, helpers later.
- Reuse the same facade names across scenarios for pattern strength.
- Provide one “good” encapsulated version vs. one “poor” inline version.
