---
id: 22
title: 22. Teams & Affiliation in Verse — Grouping, Checks, and Friendly-Fire Gates
tags: [verse, teams, affiliation, grouping, friendly-fire]
summary: Practical patterns to group players into teams, check affiliation, and guard effects like damage with friendly-fire rules.
---

# Teams & Affiliation — Patterns

This page focuses on **project-level** team patterns that don’t assume a specific engine API. We model teams with small helpers so call sites remain stable.

---

## 1) Team Model (Integer Labels)

```verse
@editable
MaxTeams : int = 4

# File-level assignment (project-side model)
# Use a parallel list for team labels; same indexing as Players.
AssignTeamLabels(Players : []player) : []int =
    TeamLabels : []int = []int{}  # conceptual creation of an int list
    i : int = 0
    loop:
        if (i >= Players.Length):
            return TeamLabels

        # Simple round-robin assignment for demonstration
        Label := i % MaxTeams
        # Append Label to TeamLabels (implementation detail depends on your list utilities)
        # Here, we conceptually assume TeamLabels[i] exists; adjust to your utilities.
        TeamLabels[i] = Label

        set i = i + 1
```

- We model teams as **ints** (`0..MaxTeams-1`) associated with player indices.

---

## 2) Affiliation Check

```verse
SameTeam?(AIndex : int, BIndex : int, Labels : []int) : logic =
    return Labels[AIndex] = Labels[BIndex]
```

- Use a dedicated helper so validation and bounds can live in one place.

---

## 3) Friendly-Fire Gate (Project Rule)

```verse
ApplyDamageIfAllowed(AttackerIdx : int, VictimIdx : int, Amount : float, Labels : []int) : void =
    if (SameTeam?(AttackerIdx, VictimIdx, Labels)):
        Print("Friendly fire blocked")
        return

    if (P : player = GetPlayspace().GetPlayers()[VictimIdx]):
        if (Char : fort_character = P.GetFortCharacter[]):
            Char.Damage(Amount)
            Print("Damage applied to victim={VictimIdx}, amount={Amount}")
```

- Gate the **effect** behind the affiliation rule.

---

## 4) Orchestration Example

```verse
OnBegin<override>() : void =
    Players := GetPlayspace().GetPlayers()
    Labels  := AssignTeamLabels(Players)

    Attacker := 0
    Victim   := 1
    ApplyDamageIfAllowed(Attacker, Victim, 10.0, Labels)
```

- Round-robin labels create predictable small teams for testing/teaching.

---

## 5) Finetuning Notes (LLM)

- Keep **labels** as simple ints for clarity.
- Show both **blocked** (same team) and **allowed** (different team) flows.
- Place effect logs after the check for clear cause→effect learning.
