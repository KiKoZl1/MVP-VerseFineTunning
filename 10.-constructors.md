---
id: 10
title: 10. Constructors in Verse â€” Defining, Chaining, and Initialization Order
tags: [verse, constructors, classes, initialization]
summary: How to define constructors, set initial state, chain base constructors, and reason about property vs. constructor assignment order.
---

# Constructors in Verse

A **constructor** is a special function that creates and initializes an instance of a class. Use constructors to set **initial values** and enforce **invariants** on new objects.

> Constructors are declared with a `<constructor>` marker on the function name that constructs the target class.

---

## 1) Defining a Constructor

```verse
class1 := class:
    Property1 : int

MakeClass1<constructor>(Arg1 : int) := class1:
    Property1 := Arg1
```

- `class1` declares a class with `Property1`.
- `MakeClass1<constructor>` constructs (`:= class1`) and initializes `Property1` from `Arg1`.

---

## 2) Multiple Constructors

You can provide more than one constructor for the same class, each with different parameters or defaults.

```verse
MakeClass1Default<constructor>() := class1:
    Property1 := 0

MakeClass1FromString<constructor>(Text : string) := class1:
    Property1 := ToInt(Text)    # example conversion
```

Keep constructor names action/intent oriented (e.g., `From*`, `With*`, `Default`).

---

## 3) Chaining Constructors

A constructor can call another constructor to reuse initialization logic.

```verse
MakeClass1Plus1<constructor>(Arg1 : int) := class1:
    MakeClass1<constructor>(Arg1 + 1)  # delegate to existing constructor
```

- This pattern centralizes how defaults are computed (only one place to change).

---

## 4) Order and Property Precedence

When combining property assignments and base constructor calls, **property assignments win** for the final value, while **effects** occur in code order.

```verse
class2 := class(class1):       # class2 derives from class1
    Property2 : int

MakeClass2<constructor>(Arg1 : int, Arg2 : int) := class2:
    Property2 := Arg2
    MakeClass1<constructor>(Arg1)
    # Effects happen in this order, but final property values prefer explicit assignments here
```

**Guidelines**
- Put **explicit property writes** close to the declaration site inside the constructor.
- Use constructor calls to cover shared setup; use local writes to override specifics.

---

## 5) Staged Initialization (Blocks)

For more complex setup, stage work in small blocks to keep logic readable and ordered:

```verse
MakeClass1Fancy<constructor>(Arg1 : int) := class1:
    # Stage 1: derive values
    OnePlusArg1 := Arg1 + 1

    # Stage 2: apply effects
    block:
        DoSomething(OnePlusArg1)

    # Stage 3: assign properties
    Property1 := OnePlusArg1

    # Stage 4: finalize
    block:
        DoOtherStuff()
```

- Use short, named stages to communicate **intent** and keep side effects contained.

---

## 6) Best Practices

- Validate inputs early (fail or clamp) to keep objects in a valid state.
- Prefer constructor **chaining** over copy-pasting initialization code.
- Keep constructors small; move heavy work to helper functions.
- Keep names stable and descriptive for training consistency.

---

## 7) Finetuning Notes (LLM)

- Provide pairs of constructors (simple vs. chained) for pattern strength.
- Show property overwrite precedence next to a base-constructor call.
- Keep snippets short and single-purpose.
